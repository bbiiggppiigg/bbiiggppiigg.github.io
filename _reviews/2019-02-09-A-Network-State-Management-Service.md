---
layout: paper_review
title: A Network-State Management Service
comments: true
excerpt_separator: <!--more-->
tags: [hot,cold]
---

![test](/images/reviews/statesman/architecture.png){:height="50%" width="50%"}

<!--more-->

## Problem 

Resolving conflicts between updates of network states in a distributed manner. The conflicting applications may or may not be in the same network layer.
For example, configuration update and firmware update ( which cause the switch to be irresponsive ) conflict with each other though one of them operates
at the forwarding behavior level and one operates at the OS level.  

## Solution

The authors abstracts the network states as multiple variable value pairs. 
To capture the problem of conflicting state assignment between variables of differetn layer, each variable is associated with a "controllability bit",
which can be used to build a dependency graph. A variable is controllable only if all its dependencies are controllable.
This way, conflicts between updates of different level of the network can be deteced by the graph, and we can even traceback
to the cause of conflict.

![dependency](/images/reviews/statesman/dependency.png)

Network Updates in Stateman primarily works around three kinds of state:
1. Observed state (OS) the view of current state of the network.
2. Proposed state (PS) are update proposal generated by each component after reading OS as input.
3. Target state (TS) is the combination of compatible PSs that might be applied to OS.

![arch](/images/reviews/statesman/architecture.png)

Statesman consits of four components:
1. Storage service that stores state variables os OS / PS and TS apersistently. Persistent states of other components
are also stored persistently here, so other components can be stateless.
2. Checker reads PS written by applications, merge valid and non-conflicting PS into TS, and check if TS is valid 
w.r.t the invariants. It also writes back the acceptance of individual PS back to the proposing devices.
3. Monitor periodically detects the current state of network and write back as OS to the storage service.
4. Updater reads OS and TS, translate the difference into update commands to update the OS to be same as TS. (in a stateless way) 


![checker](/images/reviews/statesman/checker.png)
Three kinds of conflict can happen during the execution flow of the checker:
1. TS-OS conflicts caused by latest OS changes (i.e. link failure that makes a link variable uncontrollable). These kinds of conflict
is resolved by temporarily setting a "skip-update" flag that allows the updater to bypass update of the uncontrollable variable.
2. PS-OS conflicts, again caused by latest OS changes. This kind of conflict is resolved by removing the uncontrollable variables from
the PS. The author claimed that they haven't seen negative results cuased by inconsistent view between application and OS.
3. PS-TS conflicts is solved by one of the two mechanisms: last writer wins or prioirty-based locking. 

## Advantages

1. Applications can co-exists without explicit coordination (knowledge of what other application might do).
2. Stateless of most componenets simplifies fault tolerance and retry.
3. Use of command template pool eased the process of updating heterogeneous devices.
4. Impact group split variables into sets that can be check and update independently. 

## Disadvantages

1. Allowing TS to skip updates might be problematic. Even though the network components can work on a new OS that takes
failure into account, there is no gaurantee that these failures can be repaired once an update is skipped.
2. Similar to 1, we might need to find a safe update sequence to individual variables, and it isn't clear how this is done by Statesman. 


## Related Work



